This repository contains the **Postgres database** [tables, functions and views definitions](schema) and the [functions that perform updates](handlers.py) on it based on **webhooks** that come from Trello whenever a user updates his board.

The webhooks are not expected to be handled directly by the application in this repository. It isn't meant to be listening for HTTP calls. Instead, this app listens to a **RabbitMQ** queue which records the relevant data for each received webhook until they are processed. The component that listens for the webhooks directly is [wft.recv-webhooks](https://bitbucket.org/websitesfortrello/wft.recv-webhooks).

The webhooks using the [bot](https://trello.com.com/wftbot) credentials with the **Trello API**, in response to [wft.api](https://bitbucket.org/websitesfortrello/wft.api) messages **RabbitMQ** that notifies about a newly created website. These messages contain the id of the board and the oAuth token of the board admin (the user who is trying to create a website), which we use to add the [bot](https://trello.com/wftbot) to the board before creating the webhooks. Creating the board is also supported, if the user chooses this option on the [dashboard](https://bitbucket.org/websitesfortrello/wft.website).

This repository also contains [a function that fetches the entire board contents](initial_fetch.py) (except for card comments, for which the support has never been fully implemented) in an idempotent way and updates it on the **database**. This function is called when (1) the user first creates a website (see previous paragraph); (2) a syncing conflict or unknown error is detected by one of the functions that perform updates (see first paragraph); or (3) when the user presses the "trigger a sync" button in the [dashboard](https://bitbucket.org/websitesfortrello/wft.website). Like the webhook handling, "initial fetches", as they are called, are triggered by events in the **RabbitMQ** queue, but they also can be [called manually from the CLI](initial_fetch.py#149-151).

Because this was first intended to be run first as a cron job every 3 minutes, calling [main.py](main.py) makes it start listening to the queue for 120 seconds then close itself. This is a cheap way to avoid bugs that would make everything stop if the application was to be kept running forever as the same process. The approach has many problems, but works.
